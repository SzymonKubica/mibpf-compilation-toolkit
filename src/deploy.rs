use log::debug;

use crate::{
    args::Action,
    compile::handle_compile,
    internal_representation::BinaryFileLayout,
    postprocessing::apply_postprocessing,
    pull::handle_pull,
    sign::handle_sign,
};

pub async fn handle_deploy(args: &crate::args::Action) -> Result<(), String> {
    let Action::Deploy {
        bpf_source_file,
        out_dir,
        host_network_interface,
        board_name,
        coaproot_dir,
        suit_storage_slot,
        riot_ipv6_addr,
        host_ipv6_addr,
        binary_layout,
        riot_network_interface,
    } = args
    else {
        return Err(format!("Invalid subcommand args: {:?}", args));
    };

    // The compilation process uses the RIOT build system for compiling ebpf
    // programs. It uses the rbpf.inc.mk makefile which compiles the source
    // files and applies the Femto-Containers gen_rbf script to them producing
    // the binary. Depending on the binary_layout specified above, we might
    // not want to use that binary and generate the binary ourselves (by e.g.
    // just extracting the .text section or using the custom relocate script).
    // In those cases we discard the .bin file generated by RIOT and produce it
    // on our own by using the intermediate object file that was produced during
    // the compilation process.
    handle_compile(&Action::Compile {
        bpf_source_file: bpf_source_file.to_string(),
        binary_file: Some("program.bin".to_string()),
        out_dir: out_dir.to_string(),
    })?;

    let binary_file_layout = binary_layout.as_str().parse::<BinaryFileLayout>().unwrap();

    debug!("Generating a binary with layout: {:?}", binary_file_layout);
    let object_file_name = get_object_file_name(bpf_source_file, out_dir);
    let _ = apply_postprocessing(&object_file_name, binary_file_layout, "program.bin")?;

    handle_sign(&Action::Sign {
        host_network_interface: host_network_interface.to_string(),
        board_name: board_name.to_string(),
        coaproot_dir: coaproot_dir.to_string(),
        binary_name: "program.bin".to_string(),
        suit_storage_slot: *suit_storage_slot,
    })?;

    handle_pull(&Action::Pull {
        riot_ipv6_addr: riot_ipv6_addr.to_string(),
        host_ipv6_addr: host_ipv6_addr.to_string(),
        suit_manifest: format!("suit_manifest{}.signed", suit_storage_slot),
        host_network_interface: host_network_interface.to_string(),
        riot_network_interface: riot_network_interface.to_string(),
    })
    .await?;
    Ok(())
}

pub fn get_object_file_name(bpf_source_file: &str, out_dir: &str) -> String {
    let base_name = bpf_source_file
        .split("/")
        .last()
        .unwrap()
        .split(".")
        .nth(0)
        .expect("You need to provide the .c source file");

    format!("{}/{}.o", out_dir, base_name)
}
