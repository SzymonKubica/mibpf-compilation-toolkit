use std::{fs::File, io::Write, path::PathBuf};

use log::debug;

use crate::{
    args::Action,
    compile::handle_compile,
    internal_representation::BinaryFileLayout,
    pull::handle_pull,
    relocate::{get_relocated_bytes, strip_binary},
    sign::handle_sign,
};

pub async fn handle_deploy(args: &crate::args::Action) -> Result<(), String> {
    let Action::Deploy {
        bpf_source_file,
        out_dir,
        host_network_interface,
        board_name,
        coaproot_dir,
        suit_storage_slot,
        riot_ipv6_addr,
        host_ipv6_addr,
        binary_layout,
        riot_network_interface,
    } = args
    else {
        return Err(format!("Invalid subcommand args: {:?}", args));
    };

    // The compilation process uses the RIOT build system for compiling ebpf
    // programs. It uses the rbpf.inc.mk makefile which compiles the source
    // files and applies the Femto-Containers gen_rbf script to them producing
    // the binary. Depending on the binary_layout specified above, we might
    // not want to use that binary and generate the binary ourselves (by e.g.
    // just extracting the .text section or using the custom relocate script).
    // In those cases we discard the .bin file generated by RIOT and produce it
    // on our own by using the intermediate object file that was produced during
    // the compilation process.
    handle_compile(&Action::Compile {
        bpf_source_file: bpf_source_file.to_string(),
        binary_file: Some("program.bin".to_string()),
        out_dir: out_dir.to_string(),
    })?;

    let binary_file_layout = BinaryFileLayout::from(binary_layout.as_str());

    debug!("Generating a binary with layout: {:?}", binary_file_layout);
    if binary_file_layout != BinaryFileLayout::FemtoContainersHeader {
        // In this case we need to produce the binary ourselves and place it in
        // the coaproot directory. This is because the binary produced by RIOT
        // is not suitable for the specified binary layout.
        // We need to place the binary in the coaproot directory so that the
        // signing script can find it.

        match binary_file_layout {
            BinaryFileLayout::OnlyTextSection => {
                let bytes = extract_text_section(bpf_source_file, out_dir);
                write_binary(&bytes, "program.bin");
            }
            BinaryFileLayout::FunctionRelocationMetadata => {
                let bytes = get_relocated_binary(bpf_source_file, out_dir);
                write_binary(&bytes, "program.bin");
            }
            BinaryFileLayout::RawObjectFile => {
                let object_file = get_object_file_name(bpf_source_file, out_dir);
                let _ = strip_binary(&object_file, Some(&"program.bin".to_string()));
            }
            BinaryFileLayout::FemtoContainersHeader => unreachable!(),
        }
    }

    handle_sign(&Action::Sign {
        host_network_interface: host_network_interface.to_string(),
        board_name: board_name.to_string(),
        coaproot_dir: coaproot_dir.to_string(),
        binary_name: "program.bin".to_string(),
        suit_storage_slot: *suit_storage_slot,
    })?;

    handle_pull(&Action::Pull {
        riot_ipv6_addr: riot_ipv6_addr.to_string(),
        host_ipv6_addr: host_ipv6_addr.to_string(),
        suit_manifest: format!("suit_manifest{}.signed", suit_storage_slot),
        host_network_interface: host_network_interface.to_string(),
        riot_network_interface: riot_network_interface.to_string(),
    })
    .await?;
    Ok(())
}

fn extract_text_section(bpf_source_file: &str, out_dir: &str) -> Vec<u8> {
    let object_file = get_object_file_name(bpf_source_file, out_dir);
    let path = PathBuf::from(object_file);
    let file = match elf::File::open_path(&path) {
        Ok(f) => f,
        Err(e) => panic!("Error: {:?}", e),
    };

    let text_scn = match file.get_section(".text") {
        Some(s) => s,
        None => panic!("Failed to look up elf section"),
    };

    text_scn.data.clone()
}

fn get_relocated_binary(bpf_source_file: &str, out_dir: &str) -> Vec<u8> {
    debug!("Generating the binary using the custom relocation script.");
    let object_file = get_object_file_name(bpf_source_file, out_dir);
    get_relocated_bytes(&object_file).unwrap()
}

fn get_object_file_name(bpf_source_file: &str, out_dir: &str) -> String {
    let base_name = bpf_source_file
        .split("/")
        .last()
        .unwrap()
        .split(".")
        .nth(0)
        .expect("You need to provide the .c source file");

    format!("{}/{}.o", out_dir, base_name)
}

fn write_binary(bytes: &[u8], destination: &str) {
    let mut f = File::create(destination).unwrap();
    f.write_all(bytes).unwrap();
}
