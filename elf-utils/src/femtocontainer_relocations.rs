//! This module reimplements the relocation logic that is used in the compilation
//! workflow of the Femto-Container version of the eBPF VM. It included here for
//! reference purposes and to ensure that the contribution is backwards-compatible
//! with the previous work.
//!
//! Please refer to `../RIOT/dist/tools/rbpf/rbpf` To see the implemetation details
//! of their version
//!
//! The key limitations of the implementation used by Femto-Containers version
//! of the VM are the following:
//!
//! - No support for read-only strings that aren't explicitly assigned to a
//!   variable (e.g. when calling the bpf_printf helper and using a string literal
//!   for formatting). Those strings are inserted into the `.rodata.str.1` section
//!   and aren't handled by this implementation. The extended version of the patching
//!   script that I implemented supports those strings.
//! - No support for calling functions inside of the program that aren't PC-relative.
//! - Extra instructions that aren't present in the eBPF ISA are introduced which
//!   couples the VM implementation with the behaviour of this script.

use alloc::{
    ffi::CString,
    string::{String, ToString},
    vec::Vec,
};
use goblin::{
    elf::{Elf, Reloc},
    elf64::sym::{STB_GLOBAL, STT_FUNC, STT_OBJECT},
};
use log::debug;

use crate::{
    common::{
        find_relocations, get_section_bytes, get_section_offset, round_section_length, Symbol,
        LDDW_OPCODE,
    },
    model::Lddw,
};

// In this module a prefix 'FC' is used to indicate that the structs and constants
// used here are specific to the Femto-Container implementation of the VM.
pub const FC_HEADER_SIZE: usize = 28;

// Opcodes of the new instructions introduced into the eBPF ISA by the Femto-Containers
// contribution. The purpose of those instructions is to indicate that a LDDW
// instruction is supposed to treat the immediate operand as the offset relative
// to the start of the .data or .rodata section respectively. This is done
// because the exact memory address of those sections is not known before we
// load the program into the memory of the microcontroller running the VM.
pub const FC_LDDWD_OPCODE: u32 = 0xB8;
pub const FC_LDDWR_OPCODE: u32 = 0xD8;

/// The binary generated after the relocation script has the following format:
/// - Header: Contains the information about the lengths of the remaining sections
///   functions and read-only data. See [`Header`] for more details.
/// - Data section
/// - Read-only data section
/// - Text section: Contains the code of the main entrypoint and the other functions
/// - Symbol structs: List of symbols corresponding to all functions that are
///   defined inside of the program. Those are maintained by the original
///   Femto-Container relocation script, however this metadata isn't used by
///   their version of the VM when executing the programs.
pub struct FCBinary {
    header: FCHeader,
    data: Vec<u8>,
    rodata: Vec<u8>,
    text: Vec<u8>,
    functions: Vec<Symbol>,
}

/// A header that is appended at the start of the generated binary. Contains
/// information about the length of the corresponsing sections in the binary
/// so that the VM executing the code can access the .rodata and .data sections
/// properly.
#[repr(C, packed)]
pub struct FCHeader {
    magic: u32,
    version: u32,
    flags: u32,
    data_len: u32,
    rodata_len: u32,
    text_len: u32,
    functions_len: u32,
}

impl Into<Vec<u8>> for FCBinary {
    fn into(self) -> Vec<u8> {
        let header_bytes = unsafe {
            alloc::slice::from_raw_parts(&self.header as *const _ as *const u8, FC_HEADER_SIZE)
        };
        let mut binary = Vec::from(header_bytes);
        binary.extend(self.data);
        binary.extend(self.rodata);
        binary.extend(self.text);

        // For some reason this function symbol metadata is appended at the
        // end of the binary in the FC implementation, however their version
        // of the VM doesn't use any of that information.
        for symbol in self.functions {
            let symbol: &[u8] = (&symbol).into();
            binary.extend(symbol);
        }

        binary
    }
}

/// Responsible for transforming the raw ELF files generated by llc into the
/// bespoke format that is used by the Femto-Container implementation of the
/// eBPF VM. Refer to [`FCBinary`] for more details.
pub fn assemble_femtocontainer_binary(program: &[u8]) -> Result<Vec<u8>, String> {
    let Ok(binary) = goblin::elf::Elf::parse(&program) else {
        return Err("Failed to parse the ELF binary".to_string());
    };

    // First extract the bytes contained in all three main sections
    let mut text: Vec<u8> = get_section_bytes(".text", &binary, &program);
    let mut data: Vec<u8> = get_section_bytes(".data", &binary, &program);
    let mut rodata: Vec<u8> = get_section_bytes(".rodata", &binary, &program);

    // Now we need to collect all global functions and append their names
    // to the rodata section. We also need to maintain the information
    // about the offsets at which the function names are stored.
    // This is maintained for compatibility with the bytecode patching
    // script used by FemtoContainers. It isn't actually used by their VM.
    let symbol_structs: Vec<Symbol> = extract_function_symbols(&mut rodata, &binary);

    resolve_rodata_relocations(&mut text, &binary, &program);

    round_section_length(&mut data);
    round_section_length(&mut rodata);

    // Now we write the new binary file
    let header = FCHeader {
        magic: 123,
        version: 0,
        flags: 0,
        data_len: data.len() as u32,
        rodata_len: rodata.len() as u32,
        text_len: text.len() as u32,
        functions_len: symbol_structs.len() as u32,
    };

    let output_binary: FCBinary = FCBinary {
        header,
        data,
        rodata,
        text,
        functions: symbol_structs,
    };

    Ok(output_binary.into())
}

fn extract_function_symbols(rodata: &mut Vec<u8>, binary: &Elf<'_>) -> Vec<Symbol> {
    let mut symbol_structs: Vec<Symbol> = alloc::vec![];
    for symbol in binary.syms.iter() {
        if symbol.st_type() == STT_FUNC && symbol.st_bind() == STB_GLOBAL {
            let symbol_name = binary.strtab.get_at(symbol.st_name).unwrap();

            debug!("Found global function: {}", symbol_name);
            let offset_within_text = symbol.st_value as usize;
            let offset = rodata.len();
            let name_cstr = CString::new(symbol_name).unwrap();
            rodata.extend(name_cstr.to_bytes().iter());
            // Added flags for compatiblity with rbpf
            let flags = 0;
            symbol_structs.push(Symbol {
                name_offset: offset as u16,
                flags: flags as u16,
                location_offset: offset_within_text as u16,
            });
        }
    }
    symbol_structs
}

/// Responsible for handling relocations for the read-only data used by the program.
/// It works by introducing two custom load-double-word (LDDW) instructions (
/// see [`Lddw`]) that indicate that the particular load instruction is supposed
/// to target the .rodata or .data section. This is coupled with the implementation
/// of the VM and not compatible with the default eBPF standard.
/// In case of femtocontainers we only patch relocations that are inside of the
/// text section.
fn resolve_rodata_relocations(text: &mut Vec<u8>, binary: &Elf<'_>, buffer: &[u8]) {
    let relocations = find_relocations(binary, buffer);
    let text_section_offset = get_section_offset(".text", binary, buffer).unwrap();
    for (offset, relocation) in relocations {
        if offset as u64 != text_section_offset  {
            continue;
        }
        if let Some(symbol) = binary.syms.get(relocation.r_sym) {
            let section = binary.section_headers.get(symbol.st_shndx).unwrap();
            let section_name = binary.strtab.get_at(section.sh_name).unwrap();
            match symbol.st_type() {
                STT_SECTION => {
                    debug!(
                        "Relocation at instruction {} for section {} at {}",
                        relocation.r_offset, section_name, symbol.st_value
                    )
                }
                STT_FUNC => continue, // We don't patch for functions
                _ => {
                    let symbol_name = binary.strtab.get_at(symbol.st_name).unwrap();
                    debug!(
                        "Relocation at instruction {} for symbol {} in {} at {}",
                        relocation.r_offset, symbol_name, section_name, symbol.st_value
                    )
                }
            }
        }

        patch_text(text, binary, relocation);
    }
}

fn patch_text(text: &mut [u8], binary: &Elf<'_>, reloc: Reloc) {
    debug!("Patching text for relocation symbol: {:?}", reloc);
    let symbol = binary.syms.get(reloc.r_sym).unwrap();
    let section = binary.section_headers.get(symbol.st_shndx).unwrap();
    let section_name = binary.strtab.get_at(section.sh_name).unwrap();
    let mut offset = 0;

    if symbol.st_type() == STT_OBJECT {
        debug!("No patching is performed for function calls and sections.");
        return;
    }
    offset = symbol.st_value as usize;

    // We only patch LDDW instructions
    if text[reloc.r_offset as usize] != LDDW_OPCODE as u8 {
        debug!("No LDDW instruction at {}", reloc.r_offset);
        return;
    }

    // Change the opcode of the lddwd instruction so that it uses the special
    // instructions that are understood by the VM.
    let opcode = if section_name.contains(".rodata.str") {
        FC_LDDWR_OPCODE
    } else {
        FC_LDDWD_OPCODE
    };

    // We instantiate the instruction struct to modify it
    let instr_bytes = &text[reloc.r_offset as usize..reloc.r_offset as usize + 16];
    debug!(
        "Replacing {:?} at {} with {} at {}",
        instr_bytes, reloc.r_offset, opcode, reloc.r_offset
    );

    let mut instr: Lddw = Lddw::from(instr_bytes);
    instr.opcode = opcode as u8;
    instr.immediate_l += offset as u32;

    text[reloc.r_offset as usize..reloc.r_offset as usize + 16].copy_from_slice((&instr).into());
}
