//! This module reimplements the relocation logic that is used in the compilation
//! workflow of the Femto-Container version of the eBPF VM. It included here for
//! reference purposes and to ensure that the contribution is backwards-compatible
//! with the previous work.
//!
//! Please refer to `../RIOT/dist/tools/rbpf/rbpf` To see the implemetation details
//! of their version
//!
//! The key limitations of the implementation used by Femto-Containers version
//! of the VM are the following:
//!
//! - No support for read-only strings that aren't explicitly assigned to a
//!   variable (e.g. when calling the bpf_printf helper and using a string literal
//!   for formatting). Those strings are inserted into the `.rodata.str.1` section
//!   and aren't handled by this implementation. The extended version of the patching
//!   script that I implemented supports those strings.
//! - No support for calling functions inside of the program that aren't PC-relative.
//! - Extra instructions that aren't present in the eBPF ISA are introduced which
//!   couples the VM implementation with the behaviour of this script.

use alloc::{
    ffi::CString,
    string::{String, ToString},
    vec::Vec,
};
use goblin::{
    elf::Elf,
    elf64::sym::{STB_GLOBAL, STT_FUNC},
};
use log::debug;

use crate::{
    common::{get_section_bytes, round_section_length, Symbol},
    extended_relocations::{append_string_literals, resolve_rodata_relocations},
};

// In this module a prefix 'FC' is used to indicate that the structs and constants
// used here are specific to the Femto-Container implementation of the VM.
pub const FC_HEADER_SIZE: usize = 28;

// Opcodes of the new instructions introduced into the eBPF ISA by the Femto-Containers
// contribution. The purpose of those instructions is to indicate that a LDDW
// instruction is supposed to treat the immediate operand as the offset relative
// to the start of the .data or .rodata section respectively. This is done
// because the exact memory address of those sections is not known before we
// load the program into the memory of the microcontroller running the VM.
pub const FC_LDDWD_OPCODE: u32 = 0xB8;
pub const FC_LDDWR_OPCODE: u32 = 0xD8;

/// The binary generated after the relocation script has the following format:
/// - Header: Contains the information about the lengths of the remaining sections
///   functions and read-only data. See [`Header`] for more details.
/// - Data section
/// - Read-only data section
/// - Text section: Contains the code of the main entrypoint and the other functions
/// - Symbol structs: List of symbols corresponding to all functions that are
///   defined inside of the program. Those are maintained by the original
///   Femto-Container relocation script, however this metadata isn't used by
///   their version of the VM when executing the programs.
pub struct FCBinary {
    header: FCHeader,
    data: Vec<u8>,
    rodata: Vec<u8>,
    text: Vec<u8>,
    functions: Vec<Symbol>,
}

/// A header that is appended at the start of the generated binary. Contains
/// information about the length of the corresponsing sections in the binary
/// so that the VM executing the code can access the .rodata and .data sections
/// properly.
#[repr(C, packed)]
pub struct FCHeader {
    magic: u32,
    version: u32,
    flags: u32,
    data_len: u32,
    rodata_len: u32,
    text_len: u32,
    functions_len: u32,
}

impl Into<Vec<u8>> for FCBinary {
    fn into(self) -> Vec<u8> {
        let header_bytes = unsafe {
            alloc::slice::from_raw_parts(&self.header as *const _ as *const u8, FC_HEADER_SIZE)
        };
        let mut binary = Vec::from(header_bytes);
        binary.extend(self.data);
        binary.extend(self.rodata);
        binary.extend(self.text);

        // For some reason this function symbol metadata is appended at the
        // end of the binary in the FC implementation, however their version
        // of the VM doesn't use any of that information.
        for symbol in self.functions {
            let symbol: &[u8] = (&symbol).into();
            binary.extend(symbol);
        }

        binary
    }
}

/// Responsible for transforming the raw ELF files generated by llc into the
/// bespoke format that is used by the Femto-Container implementation of the
/// eBPF VM. Refer to [`FCBinary`] for more details.
pub fn assemble_femtocontainer_binary(program: &[u8]) -> Result<Vec<u8>, String> {
    let Ok(binary) = goblin::elf::Elf::parse(&program) else {
        return Err("Failed to parse the ELF binary".to_string());
    };

    // First extract the bytes contained in all three main sections
    let mut text: Vec<u8> = get_section_bytes(".text", &binary, &program);
    let mut data: Vec<u8> = get_section_bytes(".data", &binary, &program);
    let mut rodata: Vec<u8> = get_section_bytes(".rodata", &binary, &program);

    // Now handle all string literals that aren't placed in .rodata
    // section by default. We need to append them to the .rodata section
    // and maintain the information about the offsets at which they are
    // stored so that we can relocate loads from them later on.
    let str_section_offsets = append_string_literals(&mut rodata, &binary, &program);

    // Now we need to collect all global functions and append their names
    // to the rodata section. We also need to maintain the information
    // about the offsets at which the function names are stored.
    // This is maintained for compatibility with the bytecode patching
    // script used by FemtoContainers. It isn't actually used by their VM.
    let symbol_structs: Vec<Symbol> = extract_function_symbols(&mut rodata, &binary);

    resolve_rodata_relocations(&mut text, &binary, &program, &str_section_offsets);

    round_section_length(&mut data);
    round_section_length(&mut rodata);

    // Now we write the new binary file
    let header = FCHeader {
        magic: 123,
        version: 0,
        flags: 0,
        data_len: data.len() as u32,
        rodata_len: rodata.len() as u32,
        text_len: text.len() as u32,
        functions_len: symbol_structs.len() as u32,
    };

    let output_binary: FCBinary = FCBinary {
        header,
        data,
        rodata,
        text,
        functions: symbol_structs,
    };

    Ok(output_binary.into())
}

fn extract_function_symbols(rodata: &mut Vec<u8>, binary: &Elf<'_>) -> Vec<Symbol> {
    let mut symbol_structs: Vec<Symbol> = alloc::vec![];
    for symbol in binary.syms.iter() {
        if symbol.st_type() == STT_FUNC && symbol.st_bind() == STB_GLOBAL {
            let symbol_name = binary.strtab.get_at(symbol.st_name).unwrap();

            debug!("Found global function: {}", symbol_name);
            let offset_within_text = symbol.st_value as usize;
            let offset = rodata.len();
            let name_cstr = CString::new(symbol_name).unwrap();
            rodata.extend(name_cstr.to_bytes().iter());
            // Added flags for compatiblity with rbpf
            let flags = 0;
            symbol_structs.push(Symbol {
                name_offset: offset as u16,
                flags: flags as u16,
                location_offset: offset_within_text as u16,
            });
        }
    }
    symbol_structs
}
